<!DOCTYPE html>
<html>
<head>
    <title>Estate V57 - Absolute Control</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 10px; border: 2px solid #e74c3c; pointer-events: none; }
        #overlay { position: absolute; width: 100%; height: 100%; background: #2c3e50; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        .btn { padding: 15px 40px; font-size: 20px; cursor: pointer; background: #e74c3c; border: none; color: white; font-weight: bold; border-radius: 5px; }
        .stat { color: #2ecc71; font-weight: bold; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>ESTATE V57</h1>
        <p>Fixed Controls & 'R' to Delete</p>
        <button class="btn" onclick="start()">START GAME</button>
    </div>

    <div id="ui">
        <b>W / S</b>: Forward / Back | <b>A / D</b>: Turn Left / Right<br>
        <b>E</b>: Drive/Exit | <b>B</b>: Build Mode<br>
        <b>CLICK</b>: Place Block | <b>R</b>: Delete Block<br>
        <hr>
        Mode: <span id="mode" class="stat">Walking</span> | Build: <span id="bState" class="stat">OFF</span>
    </div>

    <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, car, pet, raycaster;
        let mouse = new THREE.Vector2();
        let keys = {}, objects = [], buildableSurface = [], buildMode = false, isDriving = false;
        let vy = 0, isJumping = false, playerYaw = 0;

        function start() {
            document.getElementById('overlay').style.display = 'none';
            init();
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            raycaster = new THREE.Raycaster();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1));

            // Biomes
            const floorGeo = new THREE.PlaneGeometry(1000, 1000);
            const forest = new THREE.Mesh(floorGeo, new THREE.MeshBasicMaterial({color: 0x27ae60}));
            forest.rotation.x = -Math.PI/2; forest.position.set(-500, 0, 0); 
            scene.add(forest); buildableSurface.push(forest);

            const desert = new THREE.Mesh(floorGeo, new THREE.MeshBasicMaterial({color: 0xf1c40f}));
            desert.rotation.x = -Math.PI/2; desert.position.set(500, 0, 0); 
            scene.add(desert); buildableSurface.push(desert);

            createVillage();
            createNature();
            createCar();
            createPet();

            window.addEventListener('keydown', e => { 
                keys[e.code] = true; 
                if(e.code === 'KeyB') toggleBuild();
                if(e.code === 'KeyE') toggleDrive();
                if(e.code === 'KeyR') deleteBlock(); // New 'R' key listener
            });
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('mousedown', placeBlock);

            loop();
        }

        function createVillage() {
            const mat = new THREE.MeshBasicMaterial({color: 0x7f8c8d});
            for(let i=0; i<3; i++) {
                const house = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 10), mat);
                house.position.set(-20, 4, i * -25);
                scene.add(house);
                objects.push(house); // Add to collision list
            }
        }

        function createNature() {
            for(let i=0; i<15; i++) {
                const tree = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 2), new THREE.MeshBasicMaterial({color: 0x1b5e20}));
                tree.position.set(-Math.random()*100 - 40, 5, (Math.random()-0.5)*100);
                scene.add(tree);
                objects.push(tree);
            }
        }

        function createCar() {
            car = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 7), new THREE.MeshBasicMaterial({color: 0xe74c3c}));
            body.position.y = 1; car.add(body);
            car.position.set(15, 0, 15);
            scene.add(car);
        }

        function createPet() {
            pet = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({color: 0xf1c40f}));
            scene.add(pet);
        }

        function toggleBuild() {
            buildMode = !buildMode;
            document.getElementById('bState').innerText = buildMode ? "ON" : "OFF";
            document.getElementById('crosshair').style.borderColor = buildMode ? "lime" : "white";
        }

        function placeBlock() {
            if(!buildMode) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildableSurface);
            if (intersects.length > 0) {
                const p = intersects[0].point;
                const b = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                b.position.set(Math.round(p.x), p.y + 1, Math.round(p.z)); // Grid-snapping for cleaner builds
                scene.add(b);
                buildableSurface.push(b);
                objects.push(b);
            }
        }

        function deleteBlock() {
            if(!buildMode) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                // Don't delete houses or floor, only user blocks
                if(obj.geometry.type === "BoxGeometry" && obj.material.color.getHex() === 0xffffff) {
                    scene.remove(obj);
                    objects = objects.filter(o => o !== obj);
                    buildableSurface = buildableSurface.filter(s => s !== obj);
                }
            }
        }

        function toggleDrive() {
            if(isDriving) {
                isDriving = false;
                camera.position.y = 4;
                document.getElementById('mode').innerText = "Walking";
            } else if(camera.position.distanceTo(car.position) < 10) {
                isDriving = true;
                document.getElementById('mode').innerText = "Driving";
            }
        }

        function loop() {
            requestAnimationFrame(loop);

            if(keys['KeyA']) playerYaw += 0.05;
            if(keys['KeyD']) playerYaw -= 0.05;

            const speed = isDriving ? 1.4 : (keys['ShiftLeft'] ? 0.8 : 0.4);
            
            // --- DIRECTIONAL MATH FIX ---
            const moveDir = new THREE.Vector3();
            camera.getWorldDirection(moveDir);
            moveDir.y = 0; // Keep movement on the ground
            moveDir.normalize();

            if(isDriving) {
                car.rotation.y = playerYaw - Math.PI;
                if(keys['KeyW']) { car.position.add(moveDir.multiplyScalar(speed)); }
                if(keys['KeyS']) { car.position.sub(moveDir.multiplyScalar(speed)); }
                camera.position.set(car.position.x - Math.sin(playerYaw)*15, 8, car.position.z - Math.cos(playerYaw)*15);
                camera.lookAt(car.position);
            } else {
                let nextPos = camera.position.clone();
                if(keys['KeyW']) nextPos.add(moveDir.multiplyScalar(speed));
                if(keys['KeyS']) nextPos.sub(moveDir.multiplyScalar(speed));

                // Collision Detection
                let blocked = false;
                const playerBox = new THREE.Box3().setFromCenterAndSize(nextPos, new THREE.Vector3(2, 4, 2));
                for(let obj of objects) {
                    if(playerBox.intersectsBox(new THREE.Box3().setFromObject(obj))) {
                        blocked = true;
                        break;
                    }
                }

                if(!blocked) {
                    camera.position.x = nextPos.x;
                    camera.position.z = nextPos.z;
                }

                // Gravity/Jump
                if(keys['Space'] && !isJumping) { vy = 0.5; isJumping = true; }
                camera.position.y += vy;
                if(isJumping) vy -= 0.03;
                if(camera.position.y <= 4) { camera.position.y = 4; isJumping = false; vy = 0; }
                
                camera.rotation.set(0, playerYaw, 0);
            }

            pet.position.lerp(new THREE.Vector3(camera.position.x - 4, 1, camera.position.z - 4), 0.05);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
