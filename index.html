<!DOCTYPE html>
<html>
<head>
    <title>3D Estate V42 - Flight & Dash</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; }
        #ui { position: absolute; top: 10px; left: 10px; color: #000; font-family: monospace; background: rgba(255,255,255,0.8); padding: 15px; border-radius: 8px; pointer-events: none; border: 2px solid #2d5a27; }
        #win { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); color: gold; font-family: 'Arial Black', sans-serif; font-size: 40px; display: none; text-shadow: 2px 2px #000; text-align: center; }
        #status { font-weight: bold; color: #d63384; }
        button { pointer-events: auto; padding: 10px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="ui">
        <h2 style="margin:0">ESTATE_V42</h2>
        <p>Chests Found: <span id="score">0</span>/10</p>
        <p>Mode: <span id="status">WALKING</span></p>
        <p><b>FLY:</b> Dbl-Tap Space (Space/Shift for Up/Down)</p>
        <p><b>DASH:</b> Dbl-Tap W,A,S,D | <b>RESET:</b> 'R'</p>
    </div>
    <div id="win">YOU FOUND IT ALL!<br><button onclick="location.reload()">RESTART</button></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        window.onload = () => {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0x777777));
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 200, 100); scene.add(sunLight);
            const sunSphere = new THREE.Mesh(new THREE.SphereGeometry(15), new THREE.MeshBasicMaterial({color:0xffff00}));
            sunSphere.position.set(200, 250, -300); scene.add(sunSphere);

            // World
            const grass = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.MeshStandardMaterial({color:0x2d5a27}));
            grass.rotation.x = -Math.PI/2; grass.position.y = -1.5; scene.add(grass);

            // Cabin & Roof
            const woodMat = new THREE.MeshStandardMaterial({color:0x5d3a1a});
            const cabinWalls = [];
            function wall(w, h, d, x, y, z) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), woodMat);
                m.position.set(x,y,z); scene.add(m); cabinWalls.push(new THREE.Box3().setFromObject(m));
            }
            wall(30,15,2, 0,6,-100); wall(2,15,30, -15,6,-85); wall(2,15,30, 15,6,-85);
            wall(11,15,2, -9.5,6,-70); wall(11,15,2, 9.5,6,-70);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(24,12,4), new THREE.MeshStandardMaterial({color:0x4a1a1a}));
            roof.position.set(0,19,-85); roof.rotation.y = Math.PI/4; scene.add(roof);

            // Pond
            const pondPos = {x:45, z:-45};
            const water = new THREE.Mesh(new THREE.CircleGeometry(15,32), new THREE.MeshStandardMaterial({color:0x00ccff, transparent:true, opacity:0.6}));
            water.rotation.x = -Math.PI/2; water.position.set(pondPos.x, -0.7, pondPos.z); scene.add(water);

            // Trees
            const trees = [];
            for(let i=0; i<60; i++) {
                const tx = Math.random()*800-400, tz = Math.random()*800-400;
                if(Math.abs(tx) > 30 || (tz < -120 || tz > -50)) {
                    const g = new THREE.Group();
                    g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,8), woodMat));
                    const l = new THREE.Mesh(new THREE.ConeGeometry(5,12,8), new THREE.MeshStandardMaterial({color:0x1a4a15}));
                    l.position.y = 6; g.add(l);
                    g.position.set(tx, 2.5, tz); scene.add(g); trees.push({x:tx, z:tz, r:3});
                }
            }

            // Chests & Particles
            const chests = [];
            for(let i=0; i<10; i++){
                const c = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffaa00}));
                c.position.set(Math.random()*600-300, -0.5, Math.random()*600-300); scene.add(c); chests.push(c);
            }
            const particles = [];

            // Physics/Input
            let keys = {}, lastKeyTime = {}, isFlying = false, isJumping = false, vy = 0, dashEnd = 0, lastSpace = 0;
            camera.position.set(0, 2, 20);

            window.onkeydown = (e) => {
                const now = Date.now();
                if(e.code === 'KeyR') camera.position.set(0,2,20);
                if(e.code === 'Space') {
                    if(now - lastSpace < 300) { isFlying = !isFlying; vy = 0; document.getElementById('status').innerText = isFlying ? "FLYING" : "WALKING"; }
                    else if(!isFlying && !isJumping) { vy = 0.45; isJumping = true; }
                    lastSpace = now;
                }
                if(['KeyW','KeyA','KeyS','KeyD'].includes(e.code)) {
                    if(now - (lastKeyTime[e.code] || 0) < 300) dashEnd = now + 1000;
                    lastKeyTime[e.code] = now;
                }
                keys[e.code] = true;
            };
            window.onkeyup = (e) => keys[e.code] = false;

            let yaw = 0, pitch = 0;
            function animate() {
                requestAnimationFrame(animate);
                const now = Date.now();
                const dashing = now < dashEnd;

                // Cam
                if(keys['ArrowLeft']) yaw += 0.04; if(keys['ArrowRight']) yaw -= 0.04;
                if(keys['ArrowUp']) pitch = Math.min(1.4, pitch + 0.04); if(keys['ArrowDown']) pitch = Math.max(-1.4, pitch - 0.04);
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
                camera.fov = dashing ? 95 : 75; camera.updateProjectionMatrix();

                // Movement
                let speed = isFlying ? 1.5 : 0.8;
                if(dashing) speed *= 2.5;

                // Vertical
                if(isFlying) {
                    if(keys['Space']) camera.position.y += 0.6;
                    if(keys['ShiftLeft']) camera.position.y -= 0.6;
                    if(camera.position.y < 2) { camera.position.y = 2; isFlying = false; document.getElementById('status').innerText = "WALKING"; }
                } else if(isJumping) {
                    camera.position.y += vy; vy -= 0.02;
                    if(camera.position.y <= 2) { camera.position.y = 2; isJumping = false; vy = 0; }
                }

                let nx = camera.position.x, nz = camera.position.z;
                if(keys['KeyW']) { nx -= Math.sin(yaw)*speed; nz -= Math.cos(yaw)*speed; }
                if(keys['KeyS']) { nx += Math.sin(yaw)*speed; nz += Math.cos(yaw)*speed; }
                if(keys['KeyA']) { nx -= Math.cos(yaw)*speed; nz += Math.sin(yaw)*speed; }
                if(keys['KeyD']) { nx += Math.cos(yaw)*speed; nz -= Math.sin(yaw)*speed; }

                // Glitter
                if(keys['KeyW']||keys['KeyA']||keys['KeyS']||keys['KeyD']) {
                    const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:0xffd700}));
                    p.position.copy(camera.position).add(new THREE.Vector3(0,-1,0));
                    scene.add(p); particles.push({m:p, l:1.0});
                }

                // Collisions
                let blocked = false;
                const pPos = new THREE.Vector3(nx, camera.position.y, nz);
                if(camera.position.y < 5) {
                    cabinWalls.forEach(b => { if(b.containsPoint(pPos)) blocked = true; });
                    trees.forEach(t => { if(Math.sqrt(Math.pow(nx-t.x,2)+Math.pow(nz-t.z,2)) < t.r) blocked = true; });
                }
                if(!blocked) { camera.position.x = nx; camera.position.z = nz; }

                // Particle Clean
                for(let i=particles.length-1; i>=0; i--) {
                    particles[i].l -= 0.03; particles[i].m.scale.setScalar(particles[i].l);
                    if(particles[i].l <= 0) { scene.remove(particles[i].m); particles.splice(i,1); }
                }

                // Score
                chests.forEach(c => {
                    if(c.visible && camera.position.distanceTo(c.position) < 5) {
                        c.visible = false; document.getElementById('score').innerText = ++score;
                        if(score === 10) document.getElementById('win').style.display = 'block';
                    }
                });

                renderer.render(scene, camera);
            }
            animate();
        };
    </script>
</body>
</html>
